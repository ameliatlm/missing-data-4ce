---
title: "Predict TE from the amount of missingness"
author: Trang Le
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "htmls") })
---

```{r setup, warning=FALSE, message=FALSE}
my_dir <- '../4ce/Input'
# install.packages('stm', 'tidytext', 'furrr')

library(ggplot2)
library(readr)
library(dplyr)
library(tidyr)
library(forcats)
library(DT)
library(tibble)
library(cowplot)
# library(ggridges)
library(lubridate)
# library(topicmodels)
# library(LDAvis)   
library(stm)

theme_set(theme_bw() + 
            theme(legend.title = element_blank(),
                  panel.grid.minor = element_blank()))
```

## Read in files 
and convert to wide format

```{R message=FALSE}

#4CE long format Labs Data
patient_obs_raw <- read_csv(file.path(my_dir, 'LocalPatientObservations.csv'),
                        col_types = list(patient_num = readr::col_character())) 

patient_obs <- patient_obs_raw %>% 
  filter(concept_type == 'LAB-LOINC',
         !concept_code %in% c('2019-8', '2703-7'))

#Code, Descriptions and Ranges
lab_mapping <- read_csv('public-data/loinc-map.csv')
lab_bounds <- read_csv('public-data/lab_bounds.csv')
lab_names <- lab_bounds$short_name

demo_raw <-
  readr::read_csv(
    file.path(my_dir, 'LocalPatientSummary.csv'),
    col_types = list(patient_num = readr::col_character()),
    na = '1900-01-01'
  ) %>% 
  mutate(across(ends_with('_date') & where(is.character), lubridate::mdy)) %>% 
  mutate(
    last_discharge_date = if_else(
      !is.na(death_date) & death_date < last_discharge_date,
      death_date,
      last_discharge_date
    )
  )
```

```{r}
thrombo_codes <- read_csv('https://raw.githubusercontent.com/covidclinical/Phase2.1AKIRPackage/ac19716a4586f45c398728fcd821ca9d5baffe45/FourCePhase2.1AKI/data-raw/thromb_icd_code.csv') %>% 
  mutate(truncated_code = substr(icd_code, 1, 3)) %>% 
  pull(truncated_code) %>% 
  unique()
  
thrombo_patients <- patient_obs_raw %>% 
  filter(concept_type == 'DIAG-ICD10',
         concept_code %in% thrombo_codes,
         days_since_admission >= 0) %>% 
  select(- days_since_admission) %>% 
  distinct()

demo_df <- demo_raw %>% 
  mutate(TE = patient_num %in% unique(thrombo_patients$patient_num))

patient_obs_wide <- patient_obs %>% 
  left_join(lab_bounds, by = c('concept_code' = 'LOINC')) %>% 
  select(- concept_code) %>% 
  pivot_wider(id_cols = c(patient_num, days_since_admission),
              names_from = short_name,
              values_from = value,
              values_fn = mean) %>% 
  filter(days_since_admission <= 10,
         days_since_admission >= 0) # 10-day window

missing_by_patient <- patient_obs_wide %>% 
  group_by(patient_num) %>% 
  summarise(across(- days_since_admission, function(x) sum(!is.na(x)))) %>% 
  left_join(demo_df, by = 'patient_num')

summary(missing_by_patient)

uniq_vals <- apply(missing_by_patient, 2, function(x) length(unique(x)))
missing_by_patient <- missing_by_patient[, uniq_vals > 1]
lab_names <- intersect(lab_bounds$short_name, names(missing_by_patient))
```

## Supervised learning
```{r}
# install.packages("xgboost")
outcome <- "TE"

library(xgboost)
library(e1071)

set.seed(1)
x_mat <- missing_by_patient[, lab_names]
n_patients <- nrow(missing_by_patient)
train_idx <- sample.int(n_patients, floor(n_patients*0.8))
x_train <- as.matrix(missing_by_patient[train_idx,  lab_names])
y_train <- missing_by_patient[train_idx, outcome, drop = TRUE]

x_test <- as.matrix(missing_by_patient[- train_idx, lab_names])
y_test <- missing_by_patient[- train_idx, outcome, drop = TRUE]

bstDense <- xgboost(
  data = x_train,
  label = y_train,
  max_depth = 2,
  eta = 0.5,
  nthread = 3,
  nrounds = 20,
  objective = "binary:logistic",
  verbose = 2
)

pred <- as.numeric(predict(bstDense, x_test) > 0.5)
err_xgb <- mean(as.numeric(pred > 0.5) != y_test)


mean(y_test)
importance_matrix <- xgb.importance(model = bstDense)
print(importance_matrix)

# dat = data.frame(x = x_train, y = y_train)
svmfit = svm(x = x_train, y = y_train, type = 'C', kernel = "linear", cost = 10, scale = FALSE)
print(svmfit)
svmfit$call

y_pred <- predict(svmfit, x_test)
err <- mean(y_pred != y_test)

print(paste("test-error=", err_xgb))
print(paste("test-error=", err))
# plot(svmfit, y ~ ., dat)
```

## Unsupervised learning: LDA
```{r}
# set.seed(1)
# m <- topicmodels::LDA(x_mat, method = "Gibbs", k = 8,  control = list(alpha = 0.1))
```

```{r}
x_dfm <- x_mat %>%
  rownames_to_column('id') %>% 
  pivot_longer(- id, names_to = 'lab', values_to = 'n') %>% 
  tidytext::cast_dfm(id, lab, n)

system.time(many_models <- data.frame(K = seq(2, 8, 1)) %>%
              mutate(topic_model = furrr::future_map(K, ~ stm(
                x_dfm,
                K = .,
                seed = TRUE,
                verbose = FALSE
              ))))

heldout <- make.heldout(x_dfm)

k_result <- many_models %>%
  mutate(exclusivity = map(topic_model, exclusivity),
         semantic_coherence = map(topic_model, semanticCoherence, x_dfm),
         eval_heldout = map(topic_model, eval.heldout, heldout$missing),
         residual = map(topic_model, checkResiduals, x_dfm),
         bound =  map_dbl(topic_model, function(x) max(x$convergence$bound)),
         lfact = map_dbl(topic_model, function(x) lfactorial(x$settings$dim$K)),
         lbound = bound + lfact,
         iterations = map_dbl(topic_model, function(x) length(x$convergence$bound)))

k_result %>%
  transmute(K,
            `Lower bound` = lbound,
            Residuals = map_dbl(residual, "dispersion"),
            `Semantic coherence` = map_dbl(semantic_coherence, mean),
            `Held-out likelihood` = map_dbl(eval_heldout, "expected.heldout")) %>%
  gather(Metric, Value, -K) %>%
  ggplot(aes(K, Value, color = Metric)) +
  geom_line() +
  geom_point() +
  guides(color = FALSE) +
  scale_x_continuous(breaks = seq(2,12, 2)) +
  facet_wrap(~Metric, scales = "free_y") +
  labs(x = "K (number of topics)",
       y = NULL,
       title = "Model diagnostics by number of topics",
       subtitle = "These diagnostics indicate that a good number of topics is 4")

beepr::beep()
```

```{r}
stmfit <- stm(x_dfm, K = 4, verbose = FALSE, init.type = "Spectral", seed = TRUE)
# plot.STM(stmfit,typeC="summary",xlim=c(0,0.1))
```

```{r}
# labelTopics(stmfit)
exclusivity <- function(mod.out, M=10, frexw=.7){
  w <- frexw
  if(length(mod.out$beta$logbeta)!=1) stop("Exclusivity calculation only designed for models without content covariates")
  tbeta <- t(exp(mod.out$beta$logbeta[[1]]))
  s <- rowSums(tbeta)
  mat <- tbeta/s #normed by columns of beta now.

  ex <- apply(mat,2,rank)/nrow(mat)
  fr <- apply(tbeta,2,rank)/nrow(mat)
  frex<- 1/(w/ex + (1-w)/fr)
  index <- apply(tbeta, 2, order, decreasing=TRUE)[1:M,]
  out <- vector(length=ncol(tbeta)) 
  for(i in 1:ncol(frex)) {
    out[i] <- sum(frex[index[,i],i])
  }
  out
}
topicQuality(stmfit,documents=x_dfm)
```

```{r}
beta_mat <- exp(stmfit$beta$logbeta[[1]])
colnames(beta_mat) <- stmfit$vocab
rownames(beta_mat) <- paste('Topic', 1:4)
heatmap(t(beta_mat))
```

```{r}
theta <- stmfit$theta
cor.test(theta[,1], as.numeric(missing_by_patient$TE))
cor.test(theta[,2], as.numeric(missing_by_patient$TE))
cor.test(theta[,3], as.numeric(missing_by_patient$TE))
cor.test(theta[,4], as.numeric(missing_by_patient$TE))
```

```{r}
# x_docs = quanteda::convert(x_dfm, to = 'lda')
# toLDAvis(mod=stmfit, docs=x_docs$documents)
```