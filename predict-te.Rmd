---
title: "Predict TE from the amount of missingness"
author: Trang Le, Emily Getzen
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "htmls") })
---
```{r setup}
source('R/utils.R')
required_pkgs <- c('tidyverse', 'lubridate', 'stm', 'RColorBrewer','beepr','RcppRoll','purrr','mSTEM')
install_required(required_pkgs)

library(tidyverse)
library(lubridate)
library(stm)
library(RColorBrewer)
library(beepr)
library(RcppRoll)
library(purrr)
library(mSTEM)
```

```{r warning=FALSE, message=FALSE}
my_dir <- "../4ce/Input"

theme_set(theme_bw() +
  theme(
    legend.title = element_blank(),
    panel.grid.minor = element_blank()
  ))
```

## Read in files 
and convert to wide format

```{R message=FALSE}

# 4CE long format Labs Data

patient_obs <- read_csv(file.path(my_dir, "LocalPatientObservations.csv"),
  col_types = list(patient_num = readr::col_character())
)

# Code, Descriptions and Ranges
lab_mapping <- read_csv("public-data/loinc-map.csv")
lab_bounds <- read_csv("public-data/lab_bounds.csv")
lab_names <- lab_bounds$short_name

#Read in local patient summary

demo_raw <-
  readr::read_csv(
    file.path(my_dir, "LocalPatientSummary.csv"),
    col_types = list(patient_num = readr::col_character()),
    na = "1900-01-01"
  ) %>%
  mutate(
    across(ends_with("_date") & where(is.character), lubridate::mdy),     
    last_discharge_date = if_else(
      !is.na(death_date) & death_date < last_discharge_date,
      death_date,
      last_discharge_date
    )
  )

data_dir <- "../4ce/Input/"
```

```{r}

#Read in thrombotic icd codes. Add column "truncated code" for first three characters of each code. Extract unique truncated codes.

thrombo_codes <- read_csv("https://raw.githubusercontent.com/covidclinical/Phase2.1AKIRPackage/ac19716a4586f45c398728fcd821ca9d5baffe45/FourCePhase2.1AKI/data-raw/thromb_icd_code.csv") %>%
  mutate(truncated_code = substr(icd_code, 1, 3)) %>%
  pull(truncated_code) %>%
  unique()


#Generate list of neuro codes (obtained from neuro group)

neuro_codes <- c("R41","R27","R42","G44","G03","G04","G72","M60","G61","G65","R43","G93","F29","G40","G45","G46","I60","I61","I62","I67","H54")



```
```{r}

#Get AKI patients

#Code from AKI Group (https://github.com/covidclinical/Phase2.1AKIRPackage)

observations = patient_obs
demographics = demo_raw

demographics <- demographics %>% dplyr::mutate(patient_id=paste("Penn",patient_num,sep="_"))


    demographics_filt <- demographics %>% dplyr::mutate(time_to_severe = ifelse(severe == 1, as.numeric(as.Date(severe_date) - as.Date(admission_date)),NA))
    demographics_filt <- demographics_filt %>% dplyr::mutate(time_to_death = ifelse(deceased == 1, as.numeric(as.Date(death_date) - as.Date(admission_date)),NA))
    demographics_filt <- demographics_filt %>% dplyr::mutate(length_stay = ifelse(still_in_hospital==1,days_since_admission,as.numeric(as.Date(last_discharge_date) - as.Date(admission_date))))
    
    # Reorder the columns to be more readable
    demographics_filt <- demographics_filt %>% dplyr::select(patient_num,siteid,sex,age_group,race,length_stay,severe,time_to_severe,deceased,time_to_death)
    


diagnosis <- observations[observations$concept_type %in% c("DIAG-ICD9","DIAG-ICD10"),-6]
    colnames(diagnosis) <- c("patient_num","siteid","days_since_admission","concept_type","icd_code")
    

procedures <- observations[observations$concept_type %in% c("PROC-ICD9", "PROC-ICD10"),-6]
colnames(procedures) <- c("patient_num","siteid","days_since_admission","icd_version","procedure_code")
    
# Extract serum Cr levels
    labs_cr_aki <- observations[observations$concept_code == '2160-0',] #LOINC code for Cr 2160-0
    # Remove unnecessary columns
    labs_cr_aki <- labs_cr_aki[,-c(4,5)]
    # Filter for labs >= -90 days
    labs_cr_aki <- labs_cr_aki %>% dplyr::filter(days_since_admission >= -90)
    
    # Generate separate demographics table for patients who do not have any sCr values fulfilling 
    # the above (e.g. all the labs are before t= -90days or patient has no sCr value)
    message("Removing patients who do not have any serum creatinine values during admission...")
    pts_valid_cr <- labs_cr_aki %>% dplyr::filter(days_since_admission >= 0)
    pts_valid_cr <- unique(pts_valid_cr$patient_num)
    demog_no_cr <- demographics_filt[!(demographics_filt$patient_num %in% pts_valid_cr),]
    demographics_filt <- demographics_filt[demographics_filt$patient_num %in% pts_valid_cr,]
    labs_cr_aki <- labs_cr_aki[labs_cr_aki$patient_num %in% pts_valid_cr,]
    # There are two possible scenarios which we have to consider when detecting each AKI event:
    # (1) AKI occurs after admission
    #   - easy to detect with the formal KDIGO definition as we only need to use older data points
    #   - we can use an approach similar to what is used in the MIMIC-III data-set: use a rolling
    #     time frame and detect the lowest Cr value to use as our baseline
    # (2) Patient presents with an AKI at the time of admission 
    #   - this makes it harder for us to determine what is the true baseline especially with limited
    #     longitudinal data
    #   - Hence one way to get around this is to generate a "retrospective" baseline (i.e. look into
    #     future Cr values and find the minimum in a rolling timeframe) and use this as a surrogate
    #     baseline
    #   - Such a workaround is the only feasible way of dealing with missing retrospective data though
    #     it is likely that we may miss quite a number of true AKIs using this method
    
    # Scenario (1): AKI occurs during admission
    # Find minimum Cr level in a rolling 90 day timeframe
    message("Generating minimum Cr level in the past 90 days")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission)-90,max(days_since_admission)))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_90d = RcppRoll::roll_min(value,91,fill=NA,na.rm=TRUE,align="right")) %>% dplyr::filter(!is.na(value))
    # Find minimum Cr level in a rolling 2 day timeframe (48h)
    message("Generating minimum Cr level in the past 48h")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission)-2,max(days_since_admission)))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_48h = RcppRoll::roll_min(value,3,fill=NA,na.rm=TRUE,align="right")) %>% dplyr::filter(!is.na(value))
    
    # Scenario (2): Patient presents with an AKI already on board
    # Find minimum Cr level in a rolling 7 day timeframe
    message("Generating minimum Cr level 7 days in the future")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission),max(days_since_admission)+7))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_retro_7day = RcppRoll::roll_min(value,8,fill=NA,na.rm=TRUE,align="left")) %>% dplyr::filter(!is.na(value))
    # Find minimum Cr level in a rolling 2 day timeframe (48h)
    message("Generating minimum Cr level 48h in the future")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission),max(days_since_admission)+2))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_48h_retro = RcppRoll::roll_min(value,3,fill=NA,na.rm=TRUE,align="left")) %>% dplyr::filter(!is.na(value))
    
        

    
    
    
labs_cr_aki <- data.table::setDT(labs_cr_aki)[,':='(cr_7d = tail(labs_cr_aki$value[labs_cr_aki$patient_num==patient_num][data.table::between(labs_cr_aki$days_since_admission[labs_cr_aki$patient_num==patient_num],days_since_admission,days_since_admission+7,incbounds = TRUE)],1),cr_90d = tail(labs_cr_aki$value[labs_cr_aki$patient_num==patient_num][data.table::between(labs_cr_aki$days_since_admission[labs_cr_aki$patient_num==patient_num],days_since_admission,days_since_admission+90,incbounds = TRUE)],1)),by=c('patient_num','days_since_admission')][]
    
    # At this point, our table has these headers:
    # patient_id  siteid  days_since_admission  value min_cr_90d min_cr_48h  min_cr_retro_7day min_cr_48h_retro  cr_7d cr_90d
    
    # Now we have to start grading AKI severity at each time point
    # This approach is similar to how the MIMIC-III dataset generates AKI severity
    # Generate two columns using both the formal KDIGO AKI definition and the modified retrospective AKI definition
    message("Generating KDIGO severity grades for each serum Cr value")
    labs_cr_aki$aki_kdigo <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::aki_kdigo_grade)
    labs_cr_aki$aki_kdigo_retro <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::aki_kdigo_grade_retro)
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num,days_since_admission) %>% dplyr::mutate(aki_kdigo_final = max(aki_kdigo,aki_kdigo_retro))
    
    # Generate two columns grading AKD severity at 7d and 90d (grade 0B/C is coded as 0.5)
    labs_cr_aki$akd_7d <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::akd_grade_7d)
    labs_cr_aki$akd_90d <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::akd_grade_90d)
    
    # Now we are going to generate the start days of each AKI
    labs_cr_aki_tmp <- labs_cr_aki
    labs_cr_aki_tmp$valid = 1
    
    # Find the day of the minimum Cr used for grading AKIs (taken as baseline)
    message("Now finding the day at which the minimum serum Cr is achieved")
    labs_cr_aki_tmp <- labs_cr_aki_tmp %>% dplyr::group_by(patient_num) %>% tidyr::complete(days_since_admission = tidyr::full_seq(days_since_admission,1)) %>% dplyr::mutate(value = zoo::na.fill(value,Inf))
    labs_cr_aki_tmp2 <- labs_cr_aki_tmp
    labs_cr_aki_tmp3 <- labs_cr_aki_tmp
    labs_cr_aki_tmp2 <- labs_cr_aki_tmp2 %>% split(.$patient_num) %>% purrr::map_df(~dplyr::data_frame(.x),.id='patient_num')
    colnames(labs_cr_aki_tmp2)[2] <- "day_min"
    labs_cr_aki_tmp3 <- labs_cr_aki_tmp3 %>% split(.$patient_num) %>%  purrr::map_df(~dplyr::data_frame(.x),.id='patient_num')
    colnames(labs_cr_aki_tmp3)[2] <- "day_min_retro"
    labs_cr_aki_tmp4 <- cbind(labs_cr_aki_tmp,"day_min" = labs_cr_aki_tmp2$day_min,"day_min_retro" = labs_cr_aki_tmp3$day_min_retro)
    labs_cr_aki_tmp4 <- labs_cr_aki_tmp4[!is.na(labs_cr_aki_tmp4$valid),]
    
    # Generate delta_cr
    message("Now identifying maxima points of serum Cr")
    labs_cr_aki_tmp4 <- labs_cr_aki_tmp4 %>% dplyr::group_by(patient_num,days_since_admission) %>% dplyr::mutate(min_cr_7d_final = min(min_cr_90d,min_cr_retro_7day,na.rm=TRUE)) %>% dplyr::mutate(delta_cr = value - min_cr_7d_final)
    
    # Use the largest delta_cr to find the peak of each AKI
    labs_cr_aki_delta_maxima <- labs_cr_aki_tmp4 %>% dplyr::group_by(patient_num) %>% dplyr::filter(delta_cr %in% delta_cr[which.peaks(delta_cr,decreasing=FALSE)])
    labs_cr_aki_delta_maxima$delta_is_max = 1
    labs_cr_aki_delta_maxima <- labs_cr_aki_delta_maxima %>% dplyr::rename(delta_maxima = delta_cr) %>% dplyr::select(patient_num,days_since_admission,delta_maxima,delta_is_max)
    labs_cr_aki_tmp4 <- merge(labs_cr_aki_tmp4,labs_cr_aki_delta_maxima,by=c("patient_num","days_since_admission"),all.x=TRUE)
    
    # Filter for KDIGO grades > 0
    message("Now generating tables of all AKI events")
    labs_cr_aki_tmp5 <- labs_cr_aki_tmp4[labs_cr_aki_tmp4$aki_kdigo_final > 0,]
    labs_cr_aki_tmp5[is.na(labs_cr_aki_tmp5)] <- 0
    # Filter for maxima of delta_cr (which should give us the peaks)
    labs_cr_aki_tmp5 <- labs_cr_aki_tmp5[labs_cr_aki_tmp5$delta_is_max > 0,]
    
    # Filter and reorder columns to generate our final table of all AKI events
    labs_aki_summ <- labs_cr_aki_tmp5 %>% dplyr::select(patient_num,siteid,days_since_admission,value,day_min,day_min_retro,min_cr_90d,min_cr_48h,min_cr_retro_7day,min_cr_48h_retro,min_cr_7d_final,cr_7d,cr_90d,delta_cr,aki_kdigo,aki_kdigo_retro,aki_kdigo_final,akd_7d,akd_90d)
    
    labs_aki_summ <- labs_aki_summ %>% dplyr::distinct(patient_num,days_since_admission,.keep_all=TRUE)
    labs_aki_summ <- labs_aki_summ %>% dplyr::filter(days_since_admission >= 0)
       
    

    





```

```{r}

#Isolate patients with thrombotic events and remove the days_since_admission column. 

thrombo_patients <- patient_obs %>%
  filter(
    concept_type == "DIAG-ICD10",
    concept_code %in% thrombo_codes,
    days_since_admission >= 0
  ) %>%
  select(-days_since_admission) %>%
  distinct()


neuro_patients <- patient_obs %>%
  filter(
    concept_type == "DIAG-ICD10",
    concept_code %in% neuro_codes,
    days_since_admission >= 0
  ) %>%
  select(-days_since_admission) %>%
  distinct()

AKI_patients <- patient_obs[patient_obs$patient_num %in% as.integer(unique(labs_aki_summ$patient_num)),] 

#Isolate information for unique patients. Sum individual patients with thrombotic events. 

demo_df <- demo_raw %>%
  mutate(
    TE = patient_num %in% unique(thrombo_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$TE %>% sum()

demo_df <- demo_df %>%
  mutate(
    AKI = patient_num %in% unique(AKI_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$AKI %>% sum()

demo_df <- demo_df %>%
  mutate(
    Neuro = patient_num %in% unique(neuro_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$Neuro %>% sum()

#Generate a table that contains information about each lab for each individual patient. Each observation is identified by their patient number and days since admission, and each lab name and value is included. If there is more than one lab value for that identifier, they are averaged.

patient_obs_wide <- patient_obs %>%
  left_join(lab_bounds, by = c("concept_code" = "LOINC")) %>%
  select(-concept_code) %>%
  filter(!is.na(short_name)) %>% 
  pivot_wider(
    id_cols = c(patient_num, days_since_admission),
    names_from = short_name,
    values_from = value,
    values_fn = mean
  )
outcome <- "TE"
outcome2 <- "AKI"
outcome3 <- "Severe"
outcome4 <- "Neuro"
# outcome <- "deceased"
```

## Unsupervised learning: LDA

```{r}
upper_day <- 9
err_xgbs <- vector("numeric")
err_svms <- vector("numeric")
all_evals <- list()

#filter out observations with days since admission >= a threshold (upper_day, in this case 9 days) and days since admission  <= 0. Take out the days_since_admission column. Obtain number of lab values for each TE patient.

missing_by_patient <- patient_obs_wide %>%
  filter(
    days_since_admission <= upper_day, # 10-day window
    days_since_admission >= 0
  ) %>%
  group_by(patient_num) %>%
  summarise(across(-days_since_admission, function(x) {
    sum(!is.na(x))
  })) %>%
  left_join(demo_df, by = "patient_num")

#Obtain total number of observations per lab for TE patients

uniq_vals <-
  apply(missing_by_patient, 2, function(x) {
    length(unique(x))
  })

#Isolate lab names

lab_names <-
  intersect(lab_bounds$short_name, names(missing_by_patient))

#Remove patients that have no lab values

missing_by_patient <- missing_by_patient[, uniq_vals > 1] %>%
  mutate(sum_labs = rowSums(across(all_of(lab_names)))) %>% 
  filter(sum_labs > 0)

#Reduce dataframe to matrix with labs and values

x_mat <- missing_by_patient[, lab_names]
```

```{r}
# set.seed(1)
# m <- topicmodels::LDA(x_mat, method = "Gibbs", k = 8,  control = list(alpha = 0.1))
```

```{r cache=TRUE}
exclusivity <- function(mod.out, M = 10, frexw = .7) {
  w <- frexw
  if (length(mod.out$beta$logbeta) != 1) stop("Exclusivity calculation only designed for models without content covariates")
  tbeta <- t(exp(mod.out$beta$logbeta[[1]]))
  s <- rowSums(tbeta)
  mat <- tbeta / s # normed by columns of beta now.

  ex <- apply(mat, 2, rank) / nrow(mat)
  fr <- apply(tbeta, 2, rank) / nrow(mat)
  frex <- 1 / (w / ex + (1 - w) / fr)
  index <- apply(tbeta, 2, order, decreasing = TRUE)[1:M, ]
  out <- vector(length = ncol(tbeta))
  for (i in 1:ncol(frex)) {
    out[i] <- sum(frex[index[, i], i])
  }
  out
}

x_dfm <- x_mat %>%
  rownames_to_column("id") %>%
  pivot_longer(-id, names_to = "lab", values_to = "n") %>%
  tidytext::cast_dfm(id, lab, n)
```


```{r cache=TRUE}
system.time(many_models <- data.frame(K = seq(2, 8, 1)) %>%
  mutate(topic_model = furrr::future_map(K, ~ stm(
    x_dfm,
    K = .,
    seed = TRUE,
    verbose = FALSE
  ))))

heldout <- make.heldout(x_dfm)

k_result <- many_models %>%
  mutate(
    exclusivity = map(topic_model, exclusivity),
    semantic_coherence = map(topic_model, semanticCoherence, x_dfm),
    eval_heldout = map(topic_model, eval.heldout, heldout$missing),
    residual = map(topic_model, checkResiduals, x_dfm),
    bound = map_dbl(topic_model, function(x) max(x$convergence$bound)),
    lfact = map_dbl(topic_model, function(x) lfactorial(x$settings$dim$K)),
    lbound = bound + lfact,
    iterations = map_dbl(topic_model, function(x) length(x$convergence$bound))
  )

topic_diagnostics_penn = k_result %>%
  transmute(K,
    `Lower bound` = lbound,
    Residuals = map_dbl(residual, "dispersion"),
    `Semantic coherence` = map_dbl(semantic_coherence, mean),
    `Held-out likelihood` = map_dbl(eval_heldout, "expected.heldout")
  ) %>%
  gather(Metric, Value, -K)




topic_diagnostics_plot = k_result %>%
  transmute(K,
    `Lower bound` = lbound,
    Residuals = map_dbl(residual, "dispersion"),
    `Semantic coherence` = map_dbl(semantic_coherence, mean),
    `Held-out likelihood` = map_dbl(eval_heldout, "expected.heldout")
  ) %>%
  gather(Metric, Value, -K) %>%
  ggplot(aes(K, Value, color = Metric)) +
  geom_line() +
  geom_point() +
  guides(color = FALSE) +
  scale_x_continuous(breaks = seq(2, 12, 2)) +
  facet_wrap(~Metric, scales = "free_y") +
  labs(
    x = "K (number of topics)",
    y = NULL,
    title = "Model diagnostics by number of topics",
    subtitle = "These diagnostics indicate that a good number of topics is 5"
  )

topic_diagnostics_plot

```

We want to: maximize likelihood, lower bound, semantic coherence and minimize residuals.
- https://scholar.harvard.edu/files/dtingley/files/multimod.pdf
- http://proceedings.mlr.press/v22/taddy12/taddy12.pdf

```{r}

#Estimate the structural topic model using semi-collapsed variational EM. 

K <- 5
stmfit <- stm(x_dfm, K = K, verbose = FALSE, init.type = "Spectral", seed = TRUE)
# plot.STM(stmfit,typeC="summary",xlim=c(0,0.1))
```

```{r}
# labelTopics(stmfit)
topicQuality_penn = topicQuality(stmfit, documents = x_dfm)
```

The darker the colors, the more the presence of that lab values contribute to that topic.
```{r}

#Beta matrix contains log probabilities of labs in topics. Generate heat map of beta values for each lab.

beta_mat <- exp(stmfit$beta$logbeta[[1]])
colnames(beta_mat) <- stmfit$vocab
rownames(beta_mat) <- paste("Topic", 1:K)
heatmap(t(beta_mat), Rowv = NA, Colv = NA, 
        col= colorRampPalette(brewer.pal(8, "Blues"))(25),
        main = "Unordered")
heatmap(t(beta_mat), main = "Ordered",
        col= colorRampPalette(brewer.pal(8, "Blues"))(25))
legend(x="topleft", legend=c("min", "ave", "max"), 
     fill=colorRampPalette(brewer.pal(8, "Blues"))(3))
save(all_evals, beta_mat, file = "results/beta_matrix_penn.Rdata")
```

```{r}
theta <- stmfit$theta
TE_results_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$TE)))


AKI_results_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$AKI)))


Severity_results_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$severe)))

Neuro_results_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$Neuro)))

```

```{r}

#TE 

topic_df <- data.frame(theta, te = missing_by_patient$TE) %>% 
  pivot_longer(- te, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

TE_boxplot_penn <- topic_df %>% 
  ggplot(aes(x = te, y = value)) +
  labs(
    title = "Topic 3",
    x = "Thrombotic Event",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

TE_boxplot_penn



#AKI

topic_df <- data.frame(theta, AKI = missing_by_patient$AKI) %>% 
  pivot_longer(- AKI, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

AKI_boxplot_penn <- topic_df %>% 
  ggplot(aes(x = AKI, y = value)) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

AKI_boxplot_penn

#Severity

topic_df <- data.frame(theta, Severity = missing_by_patient$severe) %>% 
  pivot_longer(- Severity, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Severity_boxplot_penn <- topic_df %>% 
  ggplot(aes(x = Severity, y = value)) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Severity_boxplot_penn

#Neuro

topic_df <- data.frame(theta, Neuro = missing_by_patient$Neuro) %>% 
  pivot_longer(- Neuro, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Neuro_boxplot_penn <- topic_df %>% 
  ggplot(aes(x = Neuro, y = value)) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Neuro_boxplot_penn

```



To get the interactive visualization, please uncomment the following lines,
Run All (not Knit).
Please share a screenshot of the result if possible!
You may have to install the tm package with `install.packages('tm')`.
```{r}
save(topic_diagnostics_penn,topicQuality_penn,TE_results_penn,AKI_results_penn,Severity_results_penn,Neuro_results_penn,
  file = "results/penn-results-predict-te.Rdata"
)

ggsave('figs/topic_diagnostics_plot_penn.png', topic_diagnostics_plot)
ggsave('figs/TE_boxplot_penn.png', TE_boxplot_penn)
ggsave('figs/AKI_boxplot_penn.png', AKI_boxplot_penn)
ggsave('figs/Severity_boxplot_penn.png', Severity_boxplot_penn)
ggsave('figs/Neuro_boxplot_penn.png', Neuro_boxplot_penn)






```

```{r}
beepr::beep()
```

```{r}
knitr::knit_exit()
```


