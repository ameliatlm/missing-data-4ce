---
title: "Predict Outcomes from the amount of missingness"
author: Trang Le, Emily Getzen
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "htmls") })
---
```{r setup}
source('R/utils.R')
required_pkgs <- c('tidyverse', 'lubridate', 'stm', 'RColorBrewer','beepr','RcppRoll','purrr','mSTEM','Rcpp','FourCePhase2.1AKI','MCMCpack')
install_required(required_pkgs)

library(tidyverse)
library(lubridate)
library(stm)
library(RColorBrewer)
library(beepr)
library(RcppRoll)
library(purrr)
library(mSTEM)
library(Rcpp)
library(FourCePhase2.1AKI)
library(MCMCpack)
```

```{r warning=FALSE, message=FALSE}

#replace my_dir with the directory that contains your files

my_dir <- "/users/emily/Downloads"


theme_set(theme_bw() +
  theme(
    legend.title = element_blank(),
    panel.grid.minor = element_blank()
  ))
```

## Read in files 
and convert to wide format

```{R message=FALSE}

# 4CE long format Labs Data

patient_obs <- read_csv(file.path(my_dir, "LocalPatientObservations.csv"),
  col_types = list(patient_num = readr::col_character())
)

# Code, Descriptions and Ranges
lab_mapping <- read_csv("public-data/loinc-map.csv")
lab_bounds <- read_csv("public-data/lab_bounds.csv")
lab_names <- lab_bounds$short_name

#Read in local patient summary

demo_raw <-
  readr::read_csv(
    file.path(my_dir, "LocalPatientSummary.csv"),
    col_types = list(patient_num = readr::col_character()),
    na = "1900-01-01"
  ) %>%
  mutate(
    across(ends_with("_date") & where(is.character), lubridate::mdy),     
    last_discharge_date = if_else(
      !is.na(death_date) & death_date < last_discharge_date,
      death_date,
      last_discharge_date
    )
  )


```

```{r}

#Read in thrombotic icd codes. Add column "truncated code" for first three characters of each code. Extract unique truncated codes.

thrombo_codes <- read_csv("https://raw.githubusercontent.com/covidclinical/Phase2.1AKIRPackage/ac19716a4586f45c398728fcd821ca9d5baffe45/FourCePhase2.1AKI/data-raw/thromb_icd_code.csv") %>%
  mutate(truncated_code = substr(icd_code, 1, 3)) %>%
  pull(truncated_code) %>%
  unique()


#Generate list of neuro codes (obtained from neuro group)

neuro_codes <- c("R41","R27","R42","G44","G03","G04","G72","M60","G61","G65","R43","G93","F29","G40","G45","G46","I60","I61","I62","I67","H54")

ARDs_codes <- c("J80")

```

```{r}

#Get AKI patients

#Code from AKI Group (https://github.com/covidclinical/Phase2.1AKIRPackage)

observations = patient_obs
demographics = demo_raw

demographics <- demographics %>% dplyr::mutate(patient_id=paste("Penn",patient_num,sep="_"))


    demographics_filt <- demographics %>% dplyr::mutate(time_to_severe = ifelse(severe == 1, as.numeric(as.Date(severe_date) - as.Date(admission_date)),NA))
    demographics_filt <- demographics_filt %>% dplyr::mutate(time_to_death = ifelse(deceased == 1, as.numeric(as.Date(death_date) - as.Date(admission_date)),NA))
    demographics_filt <- demographics_filt %>% dplyr::mutate(length_stay = ifelse(still_in_hospital==1,days_since_admission,as.numeric(as.Date(last_discharge_date) - as.Date(admission_date))))
    
    # Reorder the columns to be more readable
    demographics_filt <- demographics_filt %>% dplyr::select(patient_num,siteid,sex,age_group,race,length_stay,severe,time_to_severe,deceased,time_to_death)
    


diagnosis <- observations[observations$concept_type %in% c("DIAG-ICD9","DIAG-ICD10"),-6]
    colnames(diagnosis) <- c("patient_num","siteid","days_since_admission","concept_type","icd_code")
    

procedures <- observations[observations$concept_type %in% c("PROC-ICD9", "PROC-ICD10"),-6]
colnames(procedures) <- c("patient_num","siteid","days_since_admission","icd_version","procedure_code")
    
# Extract serum Cr levels
    labs_cr_aki <- observations[observations$concept_code == '2160-0',] #LOINC code for Cr 2160-0
    # Remove unnecessary columns
    labs_cr_aki <- labs_cr_aki[,-c(4,5)]
    # Filter for labs >= -90 days
    labs_cr_aki <- labs_cr_aki %>% dplyr::filter(days_since_admission >= -90)
    
    # Generate separate demographics table for patients who do not have any sCr values fulfilling 
    # the above (e.g. all the labs are before t= -90days or patient has no sCr value)
    message("Removing patients who do not have any serum creatinine values during admission...")
    pts_valid_cr <- labs_cr_aki %>% dplyr::filter(days_since_admission >= 0)
    pts_valid_cr <- unique(pts_valid_cr$patient_num)
    demog_no_cr <- demographics_filt[!(demographics_filt$patient_num %in% pts_valid_cr),]
    demographics_filt <- demographics_filt[demographics_filt$patient_num %in% pts_valid_cr,]
    labs_cr_aki <- labs_cr_aki[labs_cr_aki$patient_num %in% pts_valid_cr,]
    # There are two possible scenarios which we have to consider when detecting each AKI event:
    # (1) AKI occurs after admission
    #   - easy to detect with the formal KDIGO definition as we only need to use older data points
    #   - we can use an approach similar to what is used in the MIMIC-III data-set: use a rolling
    #     time frame and detect the lowest Cr value to use as our baseline
    # (2) Patient presents with an AKI at the time of admission 
    #   - this makes it harder for us to determine what is the true baseline especially with limited
    #     longitudinal data
    #   - Hence one way to get around this is to generate a "retrospective" baseline (i.e. look into
    #     future Cr values and find the minimum in a rolling timeframe) and use this as a surrogate
    #     baseline
    #   - Such a workaround is the only feasible way of dealing with missing retrospective data though
    #     it is likely that we may miss quite a number of true AKIs using this method
    
    # Scenario (1): AKI occurs during admission
    # Find minimum Cr level in a rolling 90 day timeframe
    message("Generating minimum Cr level in the past 90 days")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission)-90,max(days_since_admission)))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_90d = RcppRoll::roll_min(value,91,fill=NA,na.rm=TRUE,align="right")) %>% dplyr::filter(!is.na(value))
    # Find minimum Cr level in a rolling 2 day timeframe (48h)
    message("Generating minimum Cr level in the past 48h")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission)-2,max(days_since_admission)))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_48h = RcppRoll::roll_min(value,3,fill=NA,na.rm=TRUE,align="right")) %>% dplyr::filter(!is.na(value))
    
    # Scenario (2): Patient presents with an AKI already on board
    # Find minimum Cr level in a rolling 7 day timeframe
    message("Generating minimum Cr level 7 days in the future")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission),max(days_since_admission)+7))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_retro_7day = RcppRoll::roll_min(value,8,fill=NA,na.rm=TRUE,align="left")) %>% dplyr::filter(!is.na(value))
    # Find minimum Cr level in a rolling 2 day timeframe (48h)
    message("Generating minimum Cr level 48h in the future")
    labs_cr_aki <- data.table::data.table(labs_cr_aki,key=c("patient_num","days_since_admission"))
    labs_cr_aki <- labs_cr_aki[data.table::CJ(unique(patient_num),seq(min(days_since_admission),max(days_since_admission)+2))] # temporarily fill in null rows for missing days - the minimum rolling code only works for consecutive data
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num) %>% dplyr::mutate(min_cr_48h_retro = RcppRoll::roll_min(value,3,fill=NA,na.rm=TRUE,align="left")) %>% dplyr::filter(!is.na(value))
    
        

    
    
    
labs_cr_aki <- data.table::setDT(labs_cr_aki)[,':='(cr_7d = tail(labs_cr_aki$value[labs_cr_aki$patient_num==patient_num][data.table::between(labs_cr_aki$days_since_admission[labs_cr_aki$patient_num==patient_num],days_since_admission,days_since_admission+7,incbounds = TRUE)],1),cr_90d = tail(labs_cr_aki$value[labs_cr_aki$patient_num==patient_num][data.table::between(labs_cr_aki$days_since_admission[labs_cr_aki$patient_num==patient_num],days_since_admission,days_since_admission+90,incbounds = TRUE)],1)),by=c('patient_num','days_since_admission')][]
    
    # At this point, our table has these headers:
    # patient_id  siteid  days_since_admission  value min_cr_90d min_cr_48h  min_cr_retro_7day min_cr_48h_retro  cr_7d cr_90d
    
    # Now we have to start grading AKI severity at each time point
    # This approach is similar to how the MIMIC-III dataset generates AKI severity
    # Generate two columns using both the formal KDIGO AKI definition and the modified retrospective AKI definition
    message("Generating KDIGO severity grades for each serum Cr value")
    labs_cr_aki$aki_kdigo <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::aki_kdigo_grade)
    labs_cr_aki$aki_kdigo_retro <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::aki_kdigo_grade_retro)
    labs_cr_aki <- labs_cr_aki %>% dplyr::group_by(patient_num,days_since_admission) %>% dplyr::mutate(aki_kdigo_final = max(aki_kdigo,aki_kdigo_retro))
    
    # Generate two columns grading AKD severity at 7d and 90d (grade 0B/C is coded as 0.5)
    labs_cr_aki$akd_7d <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::akd_grade_7d)
    labs_cr_aki$akd_90d <- apply(labs_cr_aki,1,FourCePhase2.1AKI:::akd_grade_90d)
    
    # Now we are going to generate the start days of each AKI
    labs_cr_aki_tmp <- labs_cr_aki
    labs_cr_aki_tmp$valid = 1
    
    # Find the day of the minimum Cr used for grading AKIs (taken as baseline)
    message("Now finding the day at which the minimum serum Cr is achieved")
    labs_cr_aki_tmp <- labs_cr_aki_tmp %>% dplyr::group_by(patient_num) %>% tidyr::complete(days_since_admission = tidyr::full_seq(days_since_admission,1)) %>% dplyr::mutate(value = zoo::na.fill(value,Inf))
    labs_cr_aki_tmp2 <- labs_cr_aki_tmp
    labs_cr_aki_tmp3 <- labs_cr_aki_tmp
    labs_cr_aki_tmp2 <- labs_cr_aki_tmp2 %>% split(.$patient_num) %>% purrr::map_df(~dplyr::data_frame(.x),.id='patient_num')
    colnames(labs_cr_aki_tmp2)[2] <- "day_min"
    labs_cr_aki_tmp3 <- labs_cr_aki_tmp3 %>% split(.$patient_num) %>%  purrr::map_df(~dplyr::data_frame(.x),.id='patient_num')
    colnames(labs_cr_aki_tmp3)[2] <- "day_min_retro"
    labs_cr_aki_tmp4 <- cbind(labs_cr_aki_tmp,"day_min" = labs_cr_aki_tmp2$day_min,"day_min_retro" = labs_cr_aki_tmp3$day_min_retro)
    labs_cr_aki_tmp4 <- labs_cr_aki_tmp4[!is.na(labs_cr_aki_tmp4$valid),]
    
    # Generate delta_cr
    message("Now identifying maxima points of serum Cr")
    labs_cr_aki_tmp4 <- labs_cr_aki_tmp4 %>% dplyr::group_by(patient_num,days_since_admission) %>% dplyr::mutate(min_cr_7d_final = min(min_cr_90d,min_cr_retro_7day,na.rm=TRUE)) %>% dplyr::mutate(delta_cr = value - min_cr_7d_final)
    
    # Use the largest delta_cr to find the peak of each AKI
    labs_cr_aki_delta_maxima <- labs_cr_aki_tmp4 %>% dplyr::group_by(patient_num) %>% dplyr::filter(delta_cr %in% delta_cr[which.peaks(delta_cr,decreasing=FALSE)])
    labs_cr_aki_delta_maxima$delta_is_max = 1
    labs_cr_aki_delta_maxima <- labs_cr_aki_delta_maxima %>% dplyr::rename(delta_maxima = delta_cr) %>% dplyr::select(patient_num,days_since_admission,delta_maxima,delta_is_max)
    labs_cr_aki_tmp4 <- merge(labs_cr_aki_tmp4,labs_cr_aki_delta_maxima,by=c("patient_num","days_since_admission"),all.x=TRUE)
    
    # Filter for KDIGO grades > 0
    message("Now generating tables of all AKI events")
    labs_cr_aki_tmp5 <- labs_cr_aki_tmp4[labs_cr_aki_tmp4$aki_kdigo_final > 0,]
    labs_cr_aki_tmp5[is.na(labs_cr_aki_tmp5)] <- 0
    # Filter for maxima of delta_cr (which should give us the peaks)
    labs_cr_aki_tmp5 <- labs_cr_aki_tmp5[labs_cr_aki_tmp5$delta_is_max > 0,]
    
    # Filter and reorder columns to generate our final table of all AKI events
    labs_aki_summ <- labs_cr_aki_tmp5 %>% dplyr::select(patient_num,siteid,days_since_admission,value,day_min,day_min_retro,min_cr_90d,min_cr_48h,min_cr_retro_7day,min_cr_48h_retro,min_cr_7d_final,cr_7d,cr_90d,delta_cr,aki_kdigo,aki_kdigo_retro,aki_kdigo_final,akd_7d,akd_90d)
    
    labs_aki_summ <- labs_aki_summ %>% dplyr::distinct(patient_num,days_since_admission,.keep_all=TRUE)
    labs_aki_summ <- labs_aki_summ %>% dplyr::filter(days_since_admission >= 0)
       
    

    





```

```{r}

#Isolate patients with thrombotic events and remove the days_since_admission column. 

thrombo_patients <- patient_obs %>%
  filter(
    concept_type == "DIAG-ICD10",
    concept_code %in% thrombo_codes,
    days_since_admission >= 0
  ) %>%
  dplyr::select(-days_since_admission) %>%
  distinct()


neuro_patients <- patient_obs %>%
  filter(
    concept_type == "DIAG-ICD10",
    concept_code %in% neuro_codes,
    days_since_admission >= 0
  ) %>%
  dplyr::select(-days_since_admission) %>%
  distinct()

AKI_patients <- patient_obs[patient_obs$patient_num %in% as.integer(unique(labs_aki_summ$patient_num)),] 

ARDs_patients <- patient_obs %>%
  filter(
    concept_type == "DIAG-ICD10",
    concept_code %in% ARDs_codes,
    days_since_admission >= 0
  ) %>%
  dplyr::select(-days_since_admission) %>%
  distinct()

#Isolate information for unique patients. Sum individual patients with thrombotic events. 

demo_df <- demo_raw %>%
  mutate(
    TE = patient_num %in% unique(thrombo_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$TE %>% sum()

demo_df <- demo_df %>%
  mutate(
    AKI = patient_num %in% unique(AKI_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$AKI %>% sum()

demo_df <- demo_df %>%
  mutate(
    Neuro = patient_num %in% unique(neuro_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$Neuro %>% sum()

demo_df <- demo_df %>%
  mutate(
    ARDs = patient_num %in% unique(ARDs_patients$patient_num),
    deceased = deceased == 1,
    severe = severe == 1
  )
demo_df$ARDs %>% sum()

#Generate a table that contains information about each lab for each individual patient. Each observation is identified by their patient number and days since admission, and each lab name and value is included. If there is more than one lab value for that identifier, they are averaged.

patient_obs_wide <- patient_obs %>%
  left_join(lab_bounds, by = c("concept_code" = "LOINC")) %>%
  dplyr::select(-concept_code) %>%
  filter(!is.na(short_name)) %>% 
  pivot_wider(
    id_cols = c(patient_num, days_since_admission),
    names_from = short_name,
    values_from = value,
    values_fn = mean
  )
outcome <- "TE"
outcome2 <- "AKI"
outcome3 <- "Severe"
outcome4 <- "Neuro"
# outcome <- "deceased"
```

## Unsupervised learning: LDA

```{r}
upper_day <- 9
err_xgbs <- vector("numeric")
err_svms <- vector("numeric")
all_evals <- list()

#filter out observations with days since admission >= a threshold (upper_day, in this case 9 days) and days since admission  <= 0. Take out the days_since_admission column. Obtain number of lab values for each TE patient.

missing_by_patient <- patient_obs_wide %>%
  filter(
    days_since_admission <= upper_day, # 10-day window
    days_since_admission >= 0
  ) %>%
  group_by(patient_num) %>%
  summarise(across(-days_since_admission, function(x) {
    sum(!is.na(x))
  })) %>%
  left_join(demo_df, by = "patient_num")

#Obtain total number of observations per lab for TE patients

uniq_vals <-
  apply(missing_by_patient, 2, function(x) {
    length(unique(x))
  })

#Isolate lab names

lab_names <-
  intersect(lab_bounds$short_name, names(missing_by_patient))

#Remove patients that have no lab values

missing_by_patient <- missing_by_patient[, uniq_vals > 1] %>%
  mutate(sum_labs = rowSums(across(all_of(lab_names)))) %>% 
  filter(sum_labs > 0)

#Reduce dataframe to matrix with labs and values

x_mat <- missing_by_patient[, lab_names]
```

```{r}
# set.seed(1)
# m <- topicmodels::LDA(x_mat, method = "Gibbs", k = 8,  control = list(alpha = 0.1))
```

```{r cache=TRUE}
exclusivity <- function(mod.out, M = 10, frexw = .7) {
  w <- frexw
  if (length(mod.out$beta$logbeta) != 1) stop("Exclusivity calculation only designed for models without content covariates")
  tbeta <- t(exp(mod.out$beta$logbeta[[1]]))
  s <- rowSums(tbeta)
  mat <- tbeta / s # normed by columns of beta now.

  ex <- apply(mat, 2, rank) / nrow(mat)
  fr <- apply(tbeta, 2, rank) / nrow(mat)
  frex <- 1 / (w / ex + (1 - w) / fr)
  index <- apply(tbeta, 2, order, decreasing = TRUE)[1:M, ]
  out <- vector(length = ncol(tbeta))
  for (i in 1:ncol(frex)) {
    out[i] <- sum(frex[index[, i], i])
  }
  out
}

x_dfm <- x_mat %>%
  rownames_to_column("id") %>%
  pivot_longer(-id, names_to = "lab", values_to = "n") %>%
  tidytext::cast_dfm(id, lab, n)
```


```{r cache=TRUE}
system.time(many_models <- data.frame(K = seq(2, 8, 1)) %>%
  mutate(topic_model = furrr::future_map(K, ~ stm(
    x_dfm,
    K = .,
    seed = TRUE,
    verbose = FALSE
  ))))

heldout <- make.heldout(x_dfm)

k_result <- many_models %>%
  mutate(
    exclusivity = map(topic_model, exclusivity),
    semantic_coherence = map(topic_model, semanticCoherence, x_dfm),
    eval_heldout = map(topic_model, eval.heldout, heldout$missing),
    residual = map(topic_model, checkResiduals, x_dfm),
    bound = map_dbl(topic_model, function(x) max(x$convergence$bound)),
    lfact = map_dbl(topic_model, function(x) lfactorial(x$settings$dim$K)),
    lbound = bound + lfact,
    iterations = map_dbl(topic_model, function(x) length(x$convergence$bound))
  )

topic_diagnostics = k_result %>%
  transmute(K,
    `Lower bound` = lbound,
    Residuals = map_dbl(residual, "dispersion"),
    `Semantic coherence` = map_dbl(semantic_coherence, mean),
    `Held-out likelihood` = map_dbl(eval_heldout, "expected.heldout")
  ) %>%
  gather(Metric, Value, -K) 


topic_diagnostics_wide = data.frame(matrix(ncol=0,nrow=7))
topic_diagnostics_wide$K= topic_diagnostics$K[1:7]
topic_diagnostics_wide$LB= topic_diagnostics$Value[1:7]
topic_diagnostics_wide$Res = topic_diagnostics$Value[8:14]
topic_diagnostics_wide$SC = topic_diagnostics$Value[15:21]
topic_diagnostics_wide$HL = topic_diagnostics$Value[22:28]

ind = c(which.max(topic_diagnostics_wide$LB)+1,which.max(topic_diagnostics_wide$SC)+1,which.max(topic_diagnostics_wide$HL)+1,which.min(topic_diagnostics_wide$Res)+1)

Modes <- function(x) {
  ux <- unique(x)
  tab <- tabulate(match(x, ux))
  ux[tab == max(tab)]
}

Modes(ind)

topic_diagnostics_penn = topic_diagnostics
        
                                                                                                             topic_diagnostics_plot = k_result %>%
  transmute(K,
    `Lower bound` = lbound,
    Residuals = map_dbl(residual, "dispersion"),
    `Semantic coherence` = map_dbl(semantic_coherence, mean),
    `Held-out likelihood` = map_dbl(eval_heldout, "expected.heldout")
  ) %>%
  gather(Metric, Value, -K) %>%
  ggplot(aes(K, Value, color = Metric)) +
  geom_line() +
  geom_point() +
  guides(color = FALSE) +
  scale_x_continuous(breaks = seq(2, 12, 2)) +
  facet_wrap(~Metric, scales = "free_y") +
  labs(
    x = "K (number of topics)",
    y = NULL,
    title = "Model diagnostics by number of topics"
  )

topic_diagnostics_plot

topic_diagnostics_plot_penn = topic_diagnostics_plot



```

We want to: maximize likelihood, lower bound, semantic coherence and minimize residuals.
- https://scholar.harvard.edu/files/dtingley/files/multimod.pdf
- http://proceedings.mlr.press/v22/taddy12/taddy12.pdf

```{r}

#Estimate the structural topic model using semi-collapsed variational EM. 

#Change K depending on what the optimal number of topics is based on the plots above (maximize likelihood, lower bound, semantic coherence, and minimize residuals)

K <- 5
stmfit1 <- stm(x_dfm, K = K, verbose = FALSE, init.type = "Spectral", seed = TRUE)

stmfit_beta_penn <- stmfit1$beta

save(stmfit_beta_penn,
  file = "/users/emily/Downloads/penn_beta.Rdata"
)



K <- Modes(ind)
stmfit2 <- stm(x_dfm, K = K, verbose = FALSE, init.type = "Spectral", seed = TRUE)

stmfit_beta2_penn <- stmfit2$beta

```

```{r}

topicQuality1_penn = topicQuality(stmfit1, documents = x_dfm)
topicQuality2_penn = topicQuality(stmfit2, documents = x_dfm)
```

The darker the colors, the more the presence of that lab values contribute to that topic.
```{r}

#Beta matrix contains log probabilities of labs in topics. Generate heat map of beta values for each lab.
K=5
beta_mat1 <- exp(stmfit1$beta$logbeta[[1]])
colnames(beta_mat1) <- stmfit1$vocab
rownames(beta_mat1) <- paste("Topic", 1:K)
heatmap(t(beta_mat1), Rowv = NA, Colv = NA, 
        col= colorRampPalette(brewer.pal(8, "Blues"))(25),
        main = "Unordered")
heatmap(t(beta_mat1), main = "Ordered",
        col= colorRampPalette(brewer.pal(8, "Blues"))(25))
legend(x="topleft", legend=c("min", "ave", "max"), 
     fill=colorRampPalette(brewer.pal(8, "Blues"))(3))
save(all_evals, beta_mat1, file = "results/beta_matrix1_penn.Rdata")

K=Modes(ind)
beta_mat2 <- exp(stmfit2$beta$logbeta[[1]])
colnames(beta_mat2) <- stmfit2$vocab
rownames(beta_mat2) <- paste("Topic", 1:K)
heatmap(t(beta_mat2), Rowv = NA, Colv = NA, 
        col= colorRampPalette(brewer.pal(8, "Blues"))(25),
        main = "Unordered")
heatmap(t(beta_mat2), main = "Ordered",
        col= colorRampPalette(brewer.pal(8, "Blues"))(25))
legend(x="topleft", legend=c("min", "ave", "max"), 
     fill=colorRampPalette(brewer.pal(8, "Blues"))(3))
save(all_evals, beta_mat2, file = "results/beta_matrix2_penn.Rdata")
```

```{r}
theta <- stmfit1$theta
K = 5

corrFunc <- function(var1, var2) {
  result = cor.test(var1,var2)
  data.frame(var1, var2, result[c("estimate","p.value","statistic","method")], 
             stringsAsFactors=FALSE)
}

## Pairs of variables for which we want correlations

TE_results1_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$TE))[c("estimate","p.value","statistic","method")])

AKI_results1_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$AKI))[c("estimate","p.value","statistic","method")])

Severity_results1_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$severe))[c("estimate","p.value","statistic","method")])

Neuro_results1_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$Neuro))[c("estimate","p.value","statistic","method")])

ARDs_results1_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$ARDs))[c("estimate","p.value","statistic","method")])




theta <- stmfit2$theta
K = Modes(ind)

TE_results2_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$TE))[c("estimate","p.value","statistic","method")])

AKI_results2_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$AKI))[c("estimate","p.value","statistic","method")])

Severity_results2_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$severe))[c("estimate","p.value","statistic","method")])

Neuro_results2_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$Neuro))[c("estimate","p.value","statistic","method")])

ARDs_results2_penn <- lapply(1:K, function(x) cor.test(theta[, x], as.numeric(missing_by_patient$ARDs))[c("estimate","p.value","statistic","method")])


```

```{r}

theta <- stmfit1$theta
K = 5

#TE 

topic_df <- data.frame(theta, te = missing_by_patient$TE) %>% 
  pivot_longer(- te, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

TE_boxplot1_penn <- topic_df %>% 
  ggplot(aes(x = te, y = value)) +
  labs(
    x = "Thrombotic Event",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

TE_boxplot1_penn



#AKI

topic_df <- data.frame(theta, AKI = missing_by_patient$AKI) %>% 
  pivot_longer(- AKI, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

AKI_boxplot1_penn <- topic_df %>% 
  ggplot(aes(x = AKI, y = value)) +
  labs(
    x = "Acute Kidney Injury",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

AKI_boxplot1_penn

#Severity

topic_df <- data.frame(theta, Severity = missing_by_patient$severe) %>% 
  pivot_longer(- Severity, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Severity_boxplot1_penn <- topic_df %>% 
  ggplot(aes(x = Severity, y = value)) +
  labs(
    x = "Severity",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Severity_boxplot1_penn

#Neuro

topic_df <- data.frame(theta, Neuro = missing_by_patient$Neuro) %>% 
  pivot_longer(- Neuro, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Neuro_boxplot1_penn <- topic_df %>% 
  ggplot(aes(x = Neuro, y = value)) +
  labs(
    x = "Neurological Event",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Neuro_boxplot1_penn

#ARDs

topic_df <- data.frame(theta, ARDs = missing_by_patient$ARDs) %>% 
  pivot_longer(- ARDs, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

ARDs_boxplot1_penn <- topic_df %>% 
  ggplot(aes(x = ARDs, y = value)) +
  labs(
    x = "Acute Respiratory Distress",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

ARDs_boxplot1_penn








theta <- stmfit2$theta
K = Modes(ind)

#TE 

topic_df <- data.frame(theta, te = missing_by_patient$TE) %>% 
  pivot_longer(- te, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

TE_boxplot2_penn <- topic_df %>% 
  ggplot(aes(x = te, y = value)) +
  labs(
    x = "Thrombotic Event",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

TE_boxplot2_penn



#AKI

topic_df <- data.frame(theta, AKI = missing_by_patient$AKI) %>% 
  pivot_longer(- AKI, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

AKI_boxplot2_penn <- topic_df %>% 
  ggplot(aes(x = AKI, y = value)) +
  labs(
    x = "Acute Kidney Injury",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

AKI_boxplot2_penn

#Severity

topic_df <- data.frame(theta, Severity = missing_by_patient$severe) %>% 
  pivot_longer(- Severity, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Severity_boxplot2_penn <- topic_df %>% 
  ggplot(aes(x = Severity, y = value)) +
  labs(
    x = "Severity",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Severity_boxplot2_penn

#Neuro

topic_df <- data.frame(theta, Neuro = missing_by_patient$Neuro) %>% 
  pivot_longer(- Neuro, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

Neuro_boxplot2_penn <- topic_df %>% 
  ggplot(aes(x = Neuro, y = value)) +
  labs(
    x = "Neurological Event",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

Neuro_boxplot2_penn

#ARDs

topic_df <- data.frame(theta, ARDs = missing_by_patient$ARDs) %>% 
  pivot_longer(- ARDs, names_to = 'topic') %>% 
  mutate(topic = gsub('X', 'Topic ', topic))

ARDs_boxplot2_penn <- topic_df %>% 
  ggplot(aes(x = ARDs, y = value)) +
  labs(
    x = "Acute Respiratory Distress",
    y = "Topic Value"
  ) +
  geom_boxplot(alpha = 0.2) +
  facet_wrap(~ topic, scales = 'free') +
  NULL

ARDs_boxplot2_penn

```




To get the interactive visualization, please uncomment the following lines,
Run All (not Knit).
Please share a screenshot of the result if possible!
You may have to install the tm package with `install.packages('tm')`.
```{r}
save(topic_diagnostics_penn,topicQuality1_penn,topicQuality2_penn,TE_results1_penn,AKI_results1_penn,Severity_results1_penn,Neuro_results1_penn,ARDs_results1_penn,TE_results2_penn,AKI_results2_penn,Severity_results2_penn,Neuro_results2_penn,ARDs_results2_penn,stmfit_beta_penn, stmfit_beta2_penn,
  file = "results/penn-results-predict-te.Rdata"
)

ggsave('figs/topic_diagnostics_plot_penn.png', topic_diagnostics_plot)
ggsave('figs/TE_boxplot1_penn.png', TE_boxplot1_penn)
ggsave('figs/AKI_boxplot1_penn.png', AKI_boxplot1_penn)
ggsave('figs/Severity_boxplot1_penn.png', Severity_boxplot1_penn)
ggsave('figs/Neuro_boxplot1_penn.png', Neuro_boxplot1_penn)
ggsave('figs/ARDs_boxplot1_penn.png', ARDs_boxplot1_penn)
ggsave('figs/TE_boxplot2_penn.png', TE_boxplot2_penn)
ggsave('figs/AKI_boxplot2_penn.png', AKI_boxplot2_penn)
ggsave('figs/Severity_boxplot2_penn.png', Severity_boxplot2_penn)
ggsave('figs/Neuro_boxplot2_penn.png', Neuro_boxplot2_penn)
ggsave('figs/ARDs_boxplot2_penn.png', ARDs_boxplot2_penn)






```

```{r}
beepr::beep()
```

```{r}
knitr::knit_exit()
```


